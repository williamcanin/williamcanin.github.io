<!DOCTYPE html><html id="top" lang="pt-BR" data-theme="light"><head><meta name="viewport" content="width=device-width,initial-scale=1"><meta charset="utf-8"><title>Linux: compilando e instalando o kernel em modo tradicional | William Canin</title><meta name="description" content="Quando um usuário linux já está em um nível de ..."><meta name="author" content="William C. Canin"><meta property="og:title" content="Linux: compilando e instalando o kernel em modo tradicional"><meta property="og:locale" content="pt_BR"><meta property="og:locale:alternate" content="en_US"><meta property="og:description" content="Quando um usuário linux já está em um nível de ..."><link rel="canonical" href="https://williamcanin.github.io/blog/linux-compilando-e-instalando-o-kernel-em-modo-tradicional/"><meta property="og:url" content="https://williamcanin.github.io/blog/linux-compilando-e-instalando-o-kernel-em-modo-tradicional/"><meta property="og:site_name" content="William Canin"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta property="twitter:title" content="William Canin"><meta name="robots" content="index, follow"><script type="application/ld+json">{"@context":"https://schema.org","@type":"WebSite","description":"Quando um usuário linux já está em um nível de ...","headline":"William Canin","name":"William Canin","url":"https://williamcanin.github.io/blog/linux-compilando-e-instalando-o-kernel-em-modo-tradicional/"}</script><script src="/assets/js/no_inframe.js"></script><meta http-equiv="Content-Security-Policy" content=" default-src 'self'; img-src 'self' data: https://www.google.com https://media0.giphy.com https://media4.giphy.com https://github.githubassets.com; script-src 'self' https://www.google.com https://www.gstatic.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://giscus.app https://disqus.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com https://cdn.jsdelivr.net https://giscus.app https://disqus.com; font-src 'self' https://fonts.gstatic.com https://cdnjs.cloudflare.com data:; connect-src 'self' https://www.google.com https://api.github.com; frame-src https://www.google.com https://www.youtube.com https://giscus.app https://disqus.com; object-src 'none'; base-uri 'self'; form-action 'self'; "><meta http-equiv="Strict-Transport-Security" content="max-age=31536000; includeSubDomains; preload"><meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin"><meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp"><link rel="icon" type="image/png" href="/assets/images/favicon.png"><link rel="apple-touch-icon" href="/assets/images/favicon.png"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=SUSE+Mono:ital,wght@0,100..800;1,100..800&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&amp;display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@200..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap" rel="stylesheet"><link rel="stylesheet" href="/assets/vendor/bootstrap/css/bootstrap.min.css"><script src="/assets/js/theme_load.js"></script><link rel="stylesheet" href="/assets/css/style.css"><link rel="alternate" type="application/atom+xml" title="William Canin" href="/feed.xml"></head><body data-layout="post" data-terminal-enabled="true" style="font-family:monospace!important;font-size:15.45px!important;letter-spacing:-.05em!important"><div class="container-fluid"><div class="modal fade" id="avatarModal" tabindex="-1" aria-hidden="true"><div class="modal-dialog modal-dialog-centered"><div class="modal-content bg-transparent border-0 shadow-none"><div class="modal-body d-flex justify-content-center"><img id="modalAvatar" class="avatar-img" src="" alt=""></div></div></div></div><header class="header" style="max-width:860px!important;font-family:monospace!important;font-size:15.45px!important;letter-spacing:-.05em!important"><div class="row"><div class="col-sm-3 d-flex flex-column justify-content-end header__column-home"><span>[<span class="spacer">🏠</span><a class="" href="/">/home</a>&nbsp;]</span></div><div class="col-sm-6 d-flex flex-column justify-content-end"><span class="title">Hey, I'm William!</span> <small class="description">thoughts on programming, digital wellbeing, linux</small></div><div class="col-sm-3 d-flex justify-content-end avatar"><div class="avatar-wrapper"><div class="avatar-flipper light-theme can-flip"><div class="avatar-card"><div class="avatar-front"><img id="avatarImgLight" class="avatar-img" src="/assets/images/wcanin_light.png" alt="William Canin"></div><div class="avatar-back"><img class="avatar-img" src="/assets/images/wcanin_back.png" alt="William Canin"></div></div></div><div class="avatar-flipper dark-theme can-flip"><div class="avatar-card"><div class="avatar-front"><img id="avatarImgDark" class="avatar-img" src="/assets/images/wcanin_dark.png" alt="William Canin"></div><div class="avatar-back"><img class="avatar-img" src="/assets/images/wcanin_back.png" alt="William Canin"></div></div></div></div></div></div><div class="row"><div class="col-sm d-flex justify-content-center"><div class="line-separator"></div></div></div><div class="row"><div class="col-sm d-flex justify-content-center menu"><div>weblog&nbsp;»<div class="menu-wrap-link"><span class="spacer">📝</span><a class="" href="/blog/">posts</a><strong class="separator">⨟</strong></div><span style="display:inline-block"><span class="spacer">🔍</span><a id="blog-search__btn" href="/blog/?search=open">pesquisar</a><strong class="separator">⨟</strong></span><div class="menu-wrap-link"><span class="spacer">🔖</span><a class="" href="/blog/tags/">tags</a><strong class="separator">⨟</strong></div><div class="menu-wrap-link"><span class="spacer">📰</span><a href="/feed.xml">feed</a><strong class="separator">⨟</strong></div></div></div></div><div class="row justify-content-end"><div class="col-sm-2 d-flex justify-content-end"><span id="toggle-theme"><i class="fa-solid fa-moon"></i></span></div></div></header><div class="default" style="max-width:860px!important"><main class="content"><article id="post" class="post background_focus" itemscope itemtype="http://schema.org/BlogPosting"><div class="row"><header class="post-header"><h1 class="post-title p-name" itemprop="name headline">»&nbsp;Linux: Compilando e instalando o kernel em modo tradicional</h1><div class="row post-meta"><div class="col-sm d-flex justify-content-start"><time class="dt-published" datetime="2015-08-23T20:52:44+00:00" itemprop="datePublished">23 Ago, 2015</time></div><div class="col-sm d-flex justify-content-end"><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Postado por:&nbsp;William C. Canin</span></span></div><div class="post-reading_time">[&nbsp;Leia aproximadamente em 24 minutos&nbsp;]</div></div></header><div class="post-content e-content" itemprop="articleBody"><nav id="toc" style="border-top-left-radius:0!important;border-top-right-radius:0!important" class="toc background_focus" data-toc-selector=".post-content" data-toc-max-level="3" data-toc-scroll-offset="20" data-btn-show="Abrir" data-btn-hidden="Fechar"><div class="toc-head"><h2>Índice</h2><button class="toc-toggle" aria-expanded="true" type="button"></button></div><div class="toc-list-wrapper"><ul class="toc-list" role="list"></ul><p class="toc-empty" style="display:none">No titles found. Remove TOC!</p></div></nav><h1 id="introdução">Introdução</h1><p>Quando um usuário Linux já está em um nível de usabilidade Linux a tempos, algo que ele procura saber, é como compilar um kernel, e esse post falará exatamente sobre isso, mas uma compilação sem usar kernel-package, a tradicional.</p><p>Ter uma máquina customizada para ter um melhor desempenho e reconhecimento dos hardwares, é a vontade de todos, independente de qual sistema operativo o indivíduo usa. Usuários linux, podem fazer essa customização através de uma “recompilação” no kernel Linux (se você não sabe o que é um Kernel de Linux, veja <a href="https://www.kernel.org/category/about.html">aqui</a>).</p><p>Compilar o Kernel para sua máquina, pode lhe trazer melhorias, bom desempenho e deixando a inicialização mais veloz, porém, isso é notável quando se tem uma máquina de baixa potência, pois compilar o kernel e utiliza-lo em uma máquina “top” você pode não perceber as alterações de desempenho se comparando com o kernel genérico, por ela ter uma gama de potência e um kernel genérico não deixará ela lenta. Mas é sempre recomendado deixar nosso S.O de acordo com nossos hardwares.</p><p>Caso queira compilar e deixar o núcleo que o titio Linus Torvalds criou, enxuto na sua máquina, você precisará ter um bom conhecimento dos hardwares da mesma no qual vai compilar, pois se não habilitar algo que a máquina necessita, pode não carregar modulos, e sem driver expecífico de algo que você use, por exemplo um driver da placa wireless.</p><p>Primeiro, não tenha medo, pois se você não habilitar um módulo que deveria ser habilitado, o máximo que você vai perder é o tempo da compilação do kernel, que é bem demorado dependendo da potência de sua máquina. E outra, se de um <em>“Kernel Panic”</em> você pode iniciar seu Linux com o kernel genérico de instalação quando reiniciar a máquina na próxima vez, pois quando se instala um novo kernel, seja qual for seu gerenciador de boot (Grub ou Lilo), ele vai aparecer na inicialização juntamente com o Kernel genérico/padrão de instalação do Linux (desde que atualize o Grub/Lilo), então não se preocupe. Medo devemos ter apenas do bicho papão. :stuck_out_tongue_winking_eye:</p><p>Segundo, existe várias formas para se compilar um kernel do Linux, várias distribuição Linux tem um jeito, porem irei fazer da forma mais tradicional nessa postagem, que <strong>SERVIRÁ</strong> para várias distro. Mas enfim, vamos deixar de teoria e começar logo essa aventura né? “Sigam-me os interessados!”</p><blockquote><p>NOTA: Nessa postagem, observe bem os comandos que devem ser executados com root (superusuário) e com usuário normal. Para comandos a serem executados com root (superusuário), destaquei anúncio em vermelho.</p></blockquote><h1 id="pacotes-necessários">Pacotes necessários</h1><p>Antes de começar precisamos verificar/instalar todos os pacotes necessários para a compilação do kernel. Então, instale esses pacotes de acordo com sua distro.</p><blockquote><p>Debian/Ubuntu:</p></blockquote><p><code class="language-plaintext highlighter-rouge">(Execute como root (superusuário))</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">apt-get <span class="nb">install </span>libncurses5-dev libqt3-mt-dev libgtk2.0-dev libglib2.0-dev libglade2-dev</code></pre></figure><blockquote><p>Fedora:</p></blockquote><p><code class="language-plaintext highlighter-rouge">(Execute como root (superusuário))</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">dnf <span class="nb">install </span>ncurses-devel qt3-devel libXi-devel gtk2-devel libglade2-devel</code></pre></figure><blockquote><p>Arch Linux:</p></blockquote><p><em>Não necessita instalar pacotes.</em></p><h1 id="criando-base-de-trabalho">Criando base de trabalho</h1><p>Após a instalação dos pacotes necessários, vamos criar uma pasta chamada <strong>kernel</strong> no $HOME de seu usúario e entrar nela. Essa pasta será a base onde realizaramos o download do kernel e realizar todos os processos.</p><blockquote><p>NOTA: Existe vários forma de configurar o kernel, uma delas é no diretório /usr/src, o que muitas pessoas aderem essa forma, mais eu particulamente prefiro fazer tudo no $HOME, pois assim eu não deixo sobrecarregado a minha partição do sistema (/) com os conteúdos compilados, mais isso é relativo, de gosto próprio.</p></blockquote><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">mkdir</span> <span class="nv">$HOME</span>/kernel <span class="o">&amp;&amp;</span> <span class="nb">cd</span> <span class="nv">$HOME</span>/kernel</code></pre></figure><h1 id="download-do-kernel">Download do kernel</h1><p>Agora teremos o privilégio de baixar o núcleo que o titio Linus Torvalds criou, no site: <a href="https://www.kernel.org" target="_blank">kernel.org</a></p><p>Utilizarei o gerenciador de download <strong>wget</strong>, que pra mim é o meio mais eficiente de realizar downloads no Linux, pois o mesmo te possibilita continuar o download com a opção <strong>-c</strong> caso a energia acabe…você cancele sem querer o download… a bateria do notebook exploda…ai já é demais né?! Vá se benzer! ¬¬’</p><p>Para utilizar o download com o <strong>wget</strong>, faça no terminal:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-<span class="o">{</span>VERSÃO<span class="o">}</span>.tar.xz</code></pre></figure><p>Onde {VERSÃO}, é a versão do kernel que você irá baixar. Vou supor que estaremos utilizando o kernel 4.1.6 de agora em diante nesse tutorial, que é o kernel estável mais recente no momento. Então ficaria assim:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>wget https://www.kernel.org/pub/linux/kernel/v4.x/linux-4.1.6.tar.xz</code></pre></figure><blockquote><p>DICA: Como peguei o link de download do arquivo .tar.xz? Simples, clique com o botão direito do mouse no botão “pequenino” de cor amarela no site https://www.kernel.org, e copie o <em>Endereço de link</em>.</p></blockquote><p>Para saber mais sobre outras versões de kernel, acesse: <a href="https://www.kernel.org/pub/linux/kernel/" target="_blank">kernel versões</a></p><h1 id="descompactando-o-kernel">Descompactando o kernel</h1><p>Download realizado dentro da base de trabalho, agora vamos descompactar nosso ‘ouro’ utilizando o <strong>tar</strong> e entrar dentro da pasta do nosso kernel:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>xz <span class="nt">-cd</span> linux-4.1.6.tar.xz | <span class="nb">tar </span>xvf - <span class="o">&amp;&amp;</span> <span class="nb">cd </span>linux-4.1.6</code></pre></figure><h1 id="limpando-a-base">Limpando a base</h1><p>Esse comando irá remover qualquer arquivo compilado que contenha na nossa querida pasta do kernel e volta para o estado primitivo das configurações, o que não é no nosso caso, pois não compilamos nada ainda, mas é sempre bom executá-lo para prevenção.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make mrproper <span class="o">&amp;&amp;</span> make clean</code></pre></figure><h1 id="configurando-o-kernel">Configurando o kernel</h1><h2 id="manualmente">Manualmente</h2><h3 id="reconhecendo-os-módulos-da-máquina">Reconhecendo os módulos da máquina</h3><p>A aventura começa aqui! Vamos saber os módulos e driver que sua máquina necessita e posteriormente configurarmos esses módulos no kernel. Como foi dito no começo, recompilar o kernel exige um certo reconhecimento de hardware da máquina, mas existem meios para facilitar isso, então irei dizer em partes.</p><p>Quando instalamos o Linux, o kernel da instalação é um kernel genérico, ou seja, é um kernel que funciona na maioria das máquinas, isso porque, vários módulos de vários tipo de driver são incorporados. Então isso leva a entender que o kernel padrão da instalação do Linux tem módulos que não utilizamos. Esse é um dos motivos de muitos querer recompilar o kernel, deixa-lo adaptável para vossa máquina.</p><blockquote><p>Mas como deixar o kernel adaptável à máquina e saber os módulos necessários para a mesma?</p></blockquote><p>R: Assim que instalamos o Linux e iniciamos o mesmo, os módulos que nossa máquina necessita são carregados no boot(ou não) para que o sistema funcione, correto? Com isso, existe 3 métodos (que pelo menos eu conheço) para sabermos os modulos que a máquina iniciou, necessita e está usando no momento.</p><h4 id="método-1"><strong>Método 1</strong></h4><p>O primeiro método é usar o comando:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>lspci <span class="nt">-k</span></code></pre></figure><p>O que irá retornar os drivers <strong>PCI</strong> de sua máquina no título “Kernel modules”. Exemplo do meu retorno:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>00:00.0 Host bridge: Intel Corporation 2nd Generation Core Processor Family DRAM Controller <span class="o">(</span>rev 09<span class="o">)</span>
	Subsystem: Sony Corporation Device 908b
	Flags: bus master, fast devsel, latency 0
	Capabilities: &lt;access denied&gt;
<span class="nb">.</span>
<span class="nb">.</span> <span class="c"># Resto do counteúdo retirado por ser extenso</span>
<span class="nb">.</span>

13:00.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL8111/8168/8411 PCI Express Gigabit Ethernet Controller <span class="o">(</span>rev 06<span class="o">)</span>
	Subsystem: Sony Corporation Device 908b
	Flags: bus master, fast devsel, latency 0, IRQ 28
	I/O ports at 2000 <span class="o">[</span><span class="nv">size</span><span class="o">=</span>256]
	Memory at d1404000 <span class="o">(</span>64-bit, prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>4K]
	Memory at d1400000 <span class="o">(</span>64-bit, prefetchable<span class="o">)</span> <span class="o">[</span><span class="nv">size</span><span class="o">=</span>16K]
	Capabilities: &lt;access denied&gt;
	Kernel driver <span class="k">in </span>use: r8169
	Kernel modules: r8169
</pre></td></tr></tbody></table></code></pre></figure><p>Com isso, você já saberá alguns principais módulos que sua máquina necessita.</p><h4 id="método-2"><strong>Método 2</strong></h4><p>Na verdade, esse segundo método é um complemento do primeiro para identificar os demais hardwares da máquina, porem este lista periféricos de USB.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>lsusb <span class="nt">-t</span></code></pre></figure><p>Irá retornar os drivers e possíveis módulos de entrada <strong>USB</strong> na variável “Driver”. Um exemplo:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>/:  Bus 02.Port 1: Dev 1, <span class="nv">Class</span><span class="o">=</span>root_hub, <span class="nv">Driver</span><span class="o">=</span>ehci-pci/2p, 480M
    |__ Port 1: Dev 2, If 0, <span class="nv">Class</span><span class="o">=</span>Hub, <span class="nv">Driver</span><span class="o">=</span>hub/6p, 480M
/:  Bus 01.Port 1: Dev 1, <span class="nv">Class</span><span class="o">=</span>root_hub, <span class="nv">Driver</span><span class="o">=</span>ehci-pci/2p, 480M
    |__ Port 1: Dev 2, If 0, <span class="nv">Class</span><span class="o">=</span>Hub, <span class="nv">Driver</span><span class="o">=</span>hub/6p, 480M
        |__ Port 2: Dev 3, If 0, <span class="nv">Class</span><span class="o">=</span>Video, <span class="nv">Driver</span><span class="o">=</span>uvcvideo, 480M
        |__ Port 2: Dev 3, If 1, <span class="nv">Class</span><span class="o">=</span>Video, <span class="nv">Driver</span><span class="o">=</span>uvcvideo, 480M
        |__ Port 5: Dev 5, If 0, <span class="nv">Class</span><span class="o">=</span>Wireless, <span class="nv">Driver</span><span class="o">=</span>btusb, 12M
        |__ Port 5: Dev 5, If 1, <span class="nv">Class</span><span class="o">=</span>Wireless, <span class="nv">Driver</span><span class="o">=</span>btusb, 12M
</pre></td></tr></tbody></table></code></pre></figure><h4 id="método-3"><strong>Método 3</strong></h4><p>Na terceira opção, para listar os drivers/módulos que sua máquina carregou, é usar o comando:</p><blockquote><p>NOTA: Terá que ter o programa <strong>hwinfo</strong>, instalado no linux. Instale de acordo com sua distro. Por exemplo: Debian/Ubuntu: # apt-get install hwinfo Fedora: # dnf install hwinfo Arch Linux: # pacman -S hwinfo</p></blockquote><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>hwinfo | <span class="nb">grep</span> <span class="nt">-i</span> module <span class="o">&amp;&amp;</span> hwinfo | <span class="nb">grep</span> <span class="nt">-i</span> snd</code></pre></figure><blockquote><p>NOTA: Observe que será executado dois comandos unidos por “&amp;&amp;”, você pode executa-los separadamente, para ter um retorno separado.</p></blockquote><p>Na saída desse comando, o que pertencer ao título <strong>“Driver Modules”</strong> e tudo que começar com <strong>“snd_“</strong> será um driver que sua máquina possivelmente estará usando, necessita ou teŕá que ser carregado no kernel.</p><p>Para mais informações de comandos, use: <strong>$ man hwinfo</strong>.</p><hr><p>Tem ainda o <strong>lshw</strong> que também lista seu hardware:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>lshw | <span class="nb">grep</span> <span class="nt">-i</span> driver</code></pre></figure><p>Nesse retorno, o título que está como “driver” será o importante, pois nele conterá os drivers listados. O pacote <strong>lshw</strong>, também te possibilita gravar em forma de HTML as informações de sua máquina. Para salvar todas informações do seu hardware em HTML, use o comando:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>lshw <span class="nt">-html</span> <span class="o">&gt;</span> <span class="nv">$HOME</span>/harware-info.html</code></pre></figure><p>Para mais informações de comandos, use: <strong>$ man lshw</strong>.</p><p>Se não quiser instalar pacotes que faça esse retorno de harware para você, você pode utilizar os próprios pacotes/arquivos existentes que vem por padrão nas distros, que também lhe trás informações ricas do hardware. Executando os comandos abaixo terá muitas informações:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>lscpu
<span class="nv">$ </span><span class="nb">cat</span> /proc/cpuinfo
<span class="c"># dmidecode</span></code></pre></figure><p>Sendo que o último, você deve instalar o pacote <strong>dmidecode</strong> e executá-lo como root/superusuário.</p><h3 id="iniciando-a-configuração">Iniciando a configuração</h3><p>Agora que já sabe 3 métodos, execute o comando abaixo para entrar no menu de configuração do kernel do Linux e saber como pesquisar os módulos para sua máquina de acordo com os métodos que você utilizou acima.</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make menuconfig</code></pre></figure><blockquote><p>NOTA: Existe outros tipo de layouts de menu, porem esse é o padrão e mais utilizado por todos. É menu bem intuitivo, fácil de manusear, onde as setas são as responsáveis por direcionar o foco. Mas se quiser tem o <strong>make nconfig, make config, make gconfig e make xconfig</strong>.</p></blockquote><h3 id="manuseio-para-o-make-menuconfig">Manuseio para o “make menuconfig”</h3><p>No menu de configuração kernel você irá se deparar com configurações desse tipo: [ ] , [ * ], [ M ], &lt; &gt;, -*-.</p><p><strong>Legenda:</strong></p><p>[ ] indica que o módulo(s) está desabilitado.</p><p>[ * ] indica que o(s) módulo está habilitado para ser incorporado ao kernel na compilação.</p><p>[M] indica que o(s) módulo(s) ficará habilitado mas não incorporado ao kernel.</p><p>-*- indica que o módulo dever ser incorporado ao kernel na compilação, essa opção não dá pra alterar.</p><p>Outro recurso importante é a pesquisa de módulos/driver no menu (menuconfig) de configuração do kernel, a qualquer lugar que esteje, você apertando a tecla de barra do seu teclado (/), irá abrir uma janela dialog de pesquisa. Por exemplo:</p><figure class="img-include-wrapper img-include-align-center" style="width:autopx"><img src="/assets/images/posts/search-kernel-linux.png" alt="search-kernel-linux" style="display:block;width:100%;height:auto;border-radius:2px;border:1px solid #000" class=""><figcaption class="img-include-caption">kernel search</figcaption></figure><p>Nessa dialog, você coloca um módulo/driver que foi listado com os comandos dos Métodos 1, 2 ou 3, e assim vai pesquisando os drivers para sua máquina no kernel. No exemplo abaixo, pesquisei o driver <em>“r8169</em>” que listou no comando <em>$ lspci -k</em>. Veja:</p><figure class="img-include-wrapper img-include-align-center" style="width:autopx"><img src="/assets/images/posts/search-kernel-linux-return.png" alt="search-kernel-linux-return" style="display:block;width:100%;height:auto;border-radius:2px;border:1px solid #000" class=""><figcaption class="img-include-caption">kernel search return</figcaption></figure><p>A primeira observação, é a instrução <em>“Symbol”</em>, que irá dizer o nome do módulo e no final irá dizer se o mesmo está como “M, y ou n” (sendo que “y”, é o mesmo que asterisco[ * ] no menu de configuração do kernel). A segunda observação é <em>“Prompt”</em>, que será o nome do módulo que estará imprimido no terminal. A terceira observação está em <em>“Location”</em>, é o local onde esse módulo se encontra no menu do kernel. Entre nesse diretório e configure o módulo para [M], [ * ] ou [ ].</p><p><strong>Lembrando!</strong> Se o módulo que você colocou na pesquisa obtido nos Métodos 1, 2 ou 3, retornou algum resultado diferente de <em>“No matches found”</em>, é bem provável que a máquina necessite desse módulo.</p><p>Agora é só salvar toda configuração no “botão” Save, e com isso irá criar um arquivo oculto chamado <strong>.config</strong>.</p><p><em>Guarde esse arquivo oculto …</em></p><p><em>…pois ele é o conteúdo de toda essa <strike>trabalhosa pesquisa e</strike> configuração que você teve que fazer no kernel para sua máquina.</em></p><h2 id="automaticamente">Automaticamente</h2><p>Esse é o mais rápido meio de configurar o kernel de acordo com os módulos que sua máquina necessita. Você não precisa fazer pesquisa de todos módulos que sua máquina precisa no menu de configuração do kernel. Esse meio de configurar, irá usar <em>lsmod</em> para examinar quais módulos estão atualmente em uso, e, em seguida, configurar/criar o seu <strong>“.config”</strong>. O resultado é um tempo de compilação mais curto e um kernel específico para o seu hardware. Porem, deve-se executar a partir de uma máquina que esteja usando um kernel genérico, para assim, trabalhar com os drivers para seu hardware carregados como módulos. Se não utilizar uma máquina iniciada com um kernel genérico, o <em>lsmod</em> não irá identificar os drivers embutidos no kernel. Então se estiver preparado, faça os seguintes procedimentos abaixo de acordo com sua distro Linux:</p><h3 id="carregando-config-genérico">Carregando .config genérico.</h3><p>Fedora/Debian/Ubuntu:</p><p><code class="language-plaintext highlighter-rouge">(Execute como root (superusuário))</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cp</span> /boot/config-<span class="si">$(</span><span class="nb">uname</span> <span class="nt">-r</span><span class="si">)</span> .config</code></pre></figure><p>Arch Linux:</p><p><code class="language-plaintext highlighter-rouge">(Execute como root (superusuário))</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">zcat /proc/config.gz <span class="o">&gt;</span> .config</code></pre></figure><h3 id="entrando-no-menu-do-kernel">Entrando no menu do kernel</h3><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make menuconfig</code></pre></figure><p>Vá no botão de Salvar e salve. Sai do menu do kernel.</p><h3 id="carregando-drivers-a-partir-do-lsmod">Carregando drivers a partir do lsmod</h3><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make localmodconfig</code></pre></figure><p>Pronto. Seu <strong>‘.config’</strong> já foi criado após esse comando. Porém, se depois desse comando aparecer algo como…</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">module btintel did not have configs CONFIG_BT_INTEL</code></pre></figure><p>…quer dizer que esse módulo/driver (btintel) não está configurado, então você deve configura-lo no kernel. Abra o menu do kernel (make menuconfig) e pesquisa por esse driver (como foi dito na forma manualmente lá em cima) e habilite-o. Faça isso para todos que aparecer com uma mensagem parecida com está. Depois habilite com [M] ou [ * ], e salve.</p><p>Essa forma de configurar é mamão com açucar né?, porem, irei abrir um parenteses grande:</p><blockquote><p><strong>(Você deve plugar na entrada USB dispositivos como: pendrive, HD Externos, mouse ou impressora. Se usar algum programa de criptografia que faz montagem de dispositivos, também deve estar habilitado para reconhecer o driver de CRYPT. Se você usa Steam, inicie o aplicativo pois ele usa o driver HID. Antes de criar o arquivo “.config”, o comando ‘localmodconfig’ verifica as entradas que está sendo utilizadas e possíveis programas que estão utilizando (ou necessitam) de um determinado driver para sua máquina. Essas foram algumas necessidades que precisei ‘startar’ no meu harware, porém, existem vários aplicativos que irá usar algo do seu harware, cabe a você saber quais irão usar, por isso, saber do seu harware e saber o que habilitar no kernel, é fundamental sim, mesmo utilizando a opção automatizada de configurar o “.config”. Módulos de USB, não são habilitados por padrão no boot/inicialização, e sim apenas quando estão em uso)</strong>.</p></blockquote><p>Outra forma de configurar o “.config” com o <strong>localmodconfig</strong>, é usar um parâmetro para carregar um lsmod em arquivo, ou seja, primeiro você cria um arquivo com o comando:</p><p><code class="language-plaintext highlighter-rouge">(Execute como root (superusuário))</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">lsmod <span class="o">&gt;</span> /tmp/lsmod</code></pre></figure><p>…irá inserir todos os módulos que sua máquina esta usando no arquivo <strong>“/tmp/lsmod”</strong> (porem, também deve-se plugar todos os tipos de periféricos que você usa (Pendrives, HD Externo, Impressora..etc)).</p><p>Após gerar o arquivo, já pode usar-lo com o <strong>“localmodconfig”</strong>:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make <span class="nv">LSMOD</span><span class="o">=</span>/tmp/lsmod localmodconfig</code></pre></figure><p>A vantagem de usar um arquivo gerado com o <strong>“lsmod”</strong> para armazenar seus módulos carregados, é que você plugue os periféricos (Pendrives, Impressora..etc) apenas uma única vez, não necessitado de plugar toda vez que for usar o <strong>“locamodconfig”</strong>, ou seja, já terá seus módulos carregados em um arquivo. Apenas guarde-o!</p><blockquote><p>NOTA 1: O diretório para gerar o arquivo através do “lsmod”, é opcional, não necessita ser em “/tmp”.Deve usar “make LSMOD=” com letras maiusculas no LSMOD.</p></blockquote><blockquote><p>NOTA 2: Se após executar o comando: $ make localmodconfig ou $ make LSMOD=/tmp/lsmod localmodconfig , e vir uma série de perguntas, apenas digite “Y”para todas elas caso você tenha dúvidas.</p></blockquote><blockquote><p>Observação: O arquivo contendo os módulos, criado através do comando ** lsmod<strong>, serviu apenas para a distribuição que eu gerei ele. Exemplo: Criei o arquivo no Ubuntu, e não funcionou no Arch Linux quando o incorporei no **“make LSMOD”</strong>.</p></blockquote><hr><p>Agora que já sabe os “macetes” de como listar os drivers necessários para sua máquina e como configurar um kernel adaptando para a mesma, fica a seu critério qual utilizar, opção “manualmente” (através do menuconfig) ou a opção “automaticamente” (usando o localmodconfig). Eu sempre usei a opção “automática” de configurar o kernel, nunca tive problemas. Agora se quer se aventurar e conhecer bem as opções no menu de configurações do kernel, faça a configuração “manualmente”.</p><blockquote><p>NOTA: Existe outras formas de configurar o kernel, você pode saber lendo o arquivo “README” contido no kernel, na parte “CONFIGURING the kernel”.</p></blockquote><h1 id="finalizando-as-configurações">Finalizando as configurações</h1><p>Para terminar as configurações do kernel, seja qual forma você preferiu seguir, “manualmente” ou “automaticamente”, você tem que fazer uma configuração recomendada, para que não aconteça “cagada” futuramente, porque se esquecer de fazer essa configuração, você pode substituir um kernel já existente por essa nova compilação. Essa configuração é nada mais e nada a menos que o <em>“sobrenome”</em> (vou chamar assim) que seu kernel compilado irá receber. Por padrão, o kernel já terá um “nome”, que é a versão do mesmo após compilar, mas é bom colocar um “sobrenome” para o kernel, afinal, qual filho não tem sobrenome nesse mundo, hein?! KKK ;)</p><p>Esse passo é feito através do submenu <strong>“Local version”</strong> do kernel, que tem um significado de “corda extra para o final da sua versão”. Para isso, entre no menu de configuração do kernel (caso não esteja nele) com o comando:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make menuconfig</code></pre></figure><p>Com o menu aberto, entre no seguinte local [A tecla ‘Enter’ seleciona o local]:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">-&gt; General setup
    -&gt; Local version - append to kernel release</code></pre></figure><p>Na nova janela de dialog utilize esse formato:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nt">-ARCH-RC</span><span class="o">[</span>NÚMERO]</code></pre></figure><p>Onde:</p><p>ARCH: Arquitetura do seu Linux (x86_64/i386, amd64..etc) RC: De release candidate. [NÚMERO]: O numero de vezes que a versão desse kernel foi compilado.</p><p>Você pode colocar o que quiser, porem eu acho essa forma mais compreensível de se entender. Um exemplo de como poderia ficar:</p><blockquote><p>-x86_64-RC1</p></blockquote><p>Note que tem um traço no começo, será a separação da versão do kernel(nome) com a arquitetura e compilação (sobrenome), pois quando você digitar <strong>uname -a</strong> no terminal, irá aparecer algo parecido com isso:</p><blockquote><p>Linux 4.1.6-x86_64-RC1</p></blockquote><p>Após fazer essa configuração, salve no botão ‘Save’ e saia do <em>menuconfig</em>.</p><h1 id="compilando-o-kernel">Compilando o Kernel</h1><p>Agora é a tão sonada hora de todos! Após realizar a dedicada configuração do kernel (dedicada para quem fez a configuração manualmente, claro rs) você vai poder fazer aquele “descansinho”… dar uma longa caminhada, viajar para Fernando de Noronha (esse último descanso é mentira! :D), porque dependendo da sua máquina, esse processo demora entre 1 hora ou mais (e isso não é mentira :frowning:). Então amigo, execute o comando abaixo e vá procurar algo para se distrair:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nt">-j</span><span class="o">[</span>NUMERO DE NÚCLEO DO PROCESSADOR +1] <span class="o">&amp;&amp;</span> make <span class="nt">-j</span><span class="o">[</span>NUMERO DE NÚCLEO DO PROCESSADOR +1] modules</code></pre></figure><blockquote><p><strong>NOTA:</strong> Onde está [NUMERO DE NÚCLEO DO PROCESSADOR +1] é o numero de núcleos do processsador da máquina + 1. Por exemplo, se a máquina possui 2(dois) núcleos de processadores então ficará 2+1=3. Exemplo: <strong>“make -j3 &amp;&amp; make -j3 modules”</strong>. Com isso, você fará sua máquina compilar o kernel com mais potência, o que diminuirá o tempo de compilação (e seu “descansinho” será mais rápido rs). Caso você não saíba sobre quantos núcleos tem seu processador, execute o comando <strong>lscpu</strong> e veja algo como Núcleos. Porém, recomendo que utilize o comando: <strong>$ make &amp;&amp; make modules</strong>, sem jobs(-j).</p></blockquote><h1 id="instalando-os-módulos-compilados">Instalando os módulos compilados</h1><p>Iae indivíduo! Já voltou do seu outro afazer? Vamos instalar esses módulos? Pois de agora em diante os passos são “rapidinhos”.</p><blockquote><p>NOTA: OS módulos serão instalados na pasta <strong>“/lib/modules/{VERSÃO-DO-KERNEL} -ARCH-RC[NÚMERO]”</strong> (Exemplo: /lib/modules/4.1.6-x86_64-RC1). Deve-se saber que os módulos por padrão, serão construídos nessa pasta com informações de depuração, o que acaba deixando a pasta com um tamanho de aproximadamente 2GB. Para reduzir esse tamanho, você pode usar a variável de ambiente <strong>INSTALL_MOD_STRIP</strong> com o valor de 1(um). Assim, a instalação dos módulos em <strong>“/lib/modules/4.1.6-x86_64-RC1”</strong>, será compactada. Porém, é algo opcional.</p></blockquote><p><code class="language-plaintext highlighter-rouge">IMPORTANTE! Os comandos do "Instalando os módulos compilados" deverão que ser executados como root (superusuário).</code></p><h2 id="instalação-normal">Instalação normal</h2><p><strong>Usando núcleos do processador:</strong></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nt">-j</span><span class="o">[</span>NUMERO DE NÚCLEO DO PROCESSADOR +1] modules_install</code></pre></figure><p><strong>NÃO usando núcleos do processador:</strong></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">make modules_install</code></pre></figure><h2 id="instalação-compactada">Instalação compactada</h2><p><strong>Usando núcleos do processador:</strong></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nt">-j</span><span class="o">[</span>NUMERO DE NÚCLEO DO PROCESSADOR +1] <span class="nv">INSTALL_MOD_STRIP</span><span class="o">=</span>1 modules_install</code></pre></figure><p><strong>NÃO usando núcleos do processador:</strong></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">make <span class="nv">INSTALL_MOD_STRIP</span><span class="o">=</span>1 modules_install</code></pre></figure><h1 id="copiando-o-kernel-para-o-boot">Copiando o kernel para o /boot</h1><p>Kernel compilado, módulos instalados… agora vamos copiar o <strong>“bzImage”</strong> gerado para a pasta de onde começa a iniciar todo o nosso sistema operativo Linux, que é a pasta <strong>“/boot”</strong>.</p><p><code class="language-plaintext highlighter-rouge">IMPORTANTE! O comando do "Copiando o kernel para o /boot" deverão que ser executados como root (superusuário).</code></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cp</span> <span class="nt">-v</span> <span class="nb">arch</span>/x86/boot/bzImage /boot/vmlinuz-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span></code></pre></figure><p>Lembra do “nome”, que é a versão do nosso kernel, e o “sobrenome” (arquitetura+numero da compilação) que foi inserido ao kernel em <strong>“Local version”</strong> no menuconfig? Então, use eles no <em>vmlinuz-{VERSION}-{ARCH}-{RC}</em>, por exemplo:</p><blockquote><p>vmlinuz-4.1.6-x86_64-RC1</p></blockquote><h1 id="criando-a-ramdisk">Criando a RAMDISK</h1><p>Nesse passo vai depender de sua distribuição Linux. Use um dos comandos abaixo para criação da RAMDISK:</p><p><code class="language-plaintext highlighter-rouge">IMPORTANTE! O comando do "Criando a RAMDISK" deverão que ser executados como root (superusuário)..</code></p><p>Para você, usuário de <a href="https://www.archlinux.org/" target="_blank">Arch Linux</a></p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">mkinitcpio <span class="nt">-k</span> <span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span> <span class="nt">-c</span> /etc/mkinitcpio.conf <span class="nt">-g</span> /boot/initramfs-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span>.img</code></pre></figure><p>Se você usa <a href="http://debian.org" target="_blank">Debian</a>/<a href="http://www.ubuntu.com/" target="_blank">Ubuntu</a>, faça assim:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">mkinitramfs <span class="nt">-o</span> /boot/initramfs-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span>.img /lib/modules/<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span></code></pre></figure><p>ou</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">update-initramfs <span class="nt">-c</span> <span class="nt">-k</span> <span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span></code></pre></figure><p>Para usuário <strike>"Fedorendo" (haha brincadeira)</strike> <a href="https://getfedora.org/" target="_blank">Fedora</a>, faça assim:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">dracut /boot/initramfs-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span>.img /lib/modules/<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span></code></pre></figure><h1 id="copiando-o-systemmap-e-config-para-o-boot">Copiando o “System.map” e “.config” para o /boot</h1><p><code class="language-plaintext highlighter-rouge">IMPORTANTE! O comando do "Copiando o "System.map" e ".config" para o /boot" deverão que ser executados como root (superusuário).</code></p><p>O arquivo <strong>System.map</strong> não é necessário para inicialização do Linux. É um tipo de <em>“lista telefônica”</em> de funções em uma construção particular de um kernel. O <strong>.config</strong> também não é necessário para iniciar o Linux, mas mesmo assim iremos copiar ambos para a pasta <strong>/boot</strong> para fins de organização e possíveis informações futuras. Para isso faça:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">cp </span>System.map /boot/System.map-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span>
<span class="nb">cp</span> .config /boot/config-<span class="o">{</span>VERSION<span class="o">}</span>-<span class="o">{</span>ARCH<span class="o">}</span>-<span class="o">{</span>RC<span class="o">}</span></code></pre></figure><h1 id="atualizando-o-gerenciador-de-boot">Atualizando o gerenciador de boot</h1><p><code class="language-plaintext highlighter-rouge">IMPORTANTE! O comando do "Atualizando o gerenciador de boot" deverão que ser executados como root (superusuário).</code></p><p>Após todo o processo, nesse passo você terá que atualizar o gerenciador de boot, póis só assim, a nova imagem de boot do kernel compilado será reconheciada ao inciarmos a máquina. Suponho que seu gerenciador de boot seja Grub. Então faça assim para atualizar:</p><p>Debian/Ubuntu:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">update-grub <span class="o">&amp;&amp;</span> grub-install /dev/sda</code></pre></figure><p>Fedora:</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">grub2-mkconfig <span class="nt">-o</span> /boot/grub2/grub.cfg <span class="o">&amp;&amp;</span> grub-install /dev/sda</code></pre></figure><p>Arch Linux</p><figure class="highlight"><pre><code class="language-bash" data-lang="bash">grub-mkconfig <span class="nt">-o</span> /boot/grub/grub.cfg <span class="o">&amp;&amp;</span> grub-install /dev/sda</code></pre></figure><blockquote><p>NOTA: Se sua distribuição usa o LILO como gerenciador de boot, não faça os “Copiando o kernel para o /boot”, “Criando a RAMDISK” e “Atualizando o gerenciador de boot”. Após compilar o kernel utilize o comando abaixo para realizar a instalação através do próprio script de instalação do kernel:</p></blockquote><figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="se">\#</span> make <span class="nb">install</span></code></pre></figure><h1 id="conclusão">Conclusão</h1><p>Ufa! Terminou, e eu fico por aqui! :satisfied:. Espero que sua compilação do kernel tenha sido um sucesso, mas caso não tenha, não desista, refaça os processos e procure saber sobre o problema e sobre o hardware da máquina se possível, pois o mundo Linux é muito prazeroso de se aprender. Até próxima leitor!</p></div><div class="row post-tags"><ul class="tag-list"><strong>[<span class="spacer">tags</span>]:</strong><li class="tag-list__item"><a class="tag-list__link" href="/blog/tags/compile">compile</a></li><strong class="separator">⨟</strong><li class="tag-list__item"><a class="tag-list__link" href="/blog/tags/kernel">kernel</a></li><strong class="separator">⨟</strong><li class="tag-list__item"><a class="tag-list__link" href="/blog/tags/linux">linux</a></li><strong class="separator">⨟</strong></ul></div></div><div class="post-end text-center">////&nbsp;end of post&nbsp;////</div><div id="giscus" class="row comments"><h1 class="comments-title">[&nbsp;comentários&nbsp;]</h1><div class="row comments-content"><script src="https://giscus.app/client.js" data-repo="williamcanin/williamcanin.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnk0MDMyOTUzOQ==" data-repo-category="Comments" data-category-id="DIC_kwDOAmdhQ84CwLFu" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="noborder_light" data-lang="pt" crossorigin="anonymous" async></script></div></div><div class="row related-posts"><h3 class="related-posts-title">[&nbsp;postagens relacionadas&nbsp;]</h3><ul class="related-posts-list"><li class="related-posts-list__item"><span class="related-posts-list__meta">21 Jun, 2018</span>&nbsp;»&nbsp;<a class="related-posts-list__link" href="/blog/instalando-python-automaticamente-em-qualquer-sistema-linux/">Instalando Python tarball em qualquer sistema Linux.</a></li><li class="related-posts-list__item"><span class="related-posts-list__meta">16 Out, 2017</span>&nbsp;»&nbsp;<a class="related-posts-list__link" href="/blog/criptografando-a-particao-home-no-linux/">Criptografando a partição HOME no Linux</a></li><li class="related-posts-list__item"><span class="related-posts-list__meta">26 Jul, 2015</span>&nbsp;»&nbsp;<a class="related-posts-list__link" href="/blog/linux-boot-a-start-job-is-running-for-dev-disk-by/">Linux Boot: A start job is running for dev-disk-by</a></li><li class="related-posts-list__item"><span class="related-posts-list__meta">14 Mai, 2015</span>&nbsp;»&nbsp;<a class="related-posts-list__link" href="/blog/compilando-e-configurando-squid-transparent/">Compilando e configurando Squid</a></li><li class="related-posts-list__item"><span class="related-posts-list__meta">29 Abr, 2015</span>&nbsp;»&nbsp;<a class="related-posts-list__link" href="/blog/arquivos-de-execucao-no-linux/">Arquivos de execução no Linux</a></li></ul></div></article></main></div><footer class="fixed-bottom footer"><div class="row top"><div class="col-md d-flex justify-content-end"><a id="top-link" class="top-link" href="#top">⇡</a></div></div><div class="row footer-wrapper"><div class="col-md footer-copyright-wrap"><div class="footer-copyright">©&nbsp;William Canin&nbsp;2015-2025&nbsp;|&nbsp;<a href="/licenses/">Licenças</a></div></div><div class="col-md footer-message-wrap"><div class="footer-message"><p>Simplicity is a feature, not a bug.</p></div></div><div class="col-md footer-made-by-wrap"><div class="footer-made-by">Using the <a href="https://rawfeed.github.io/rawfeed-jekyll" target="_blank" rel="noopener noreferrer">rawfeed</a> theme for <a href="https://jekyllrb.com" target="_blank" rel="noopener noreferrer">Jekyll</a>.</div></div></div></footer></div><script src="/assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script><script src="/assets/js/default.js"></script><script src="/assets/js/home.js"></script><script src="/assets/vendor/simple-jekyll-search.min.js"></script><script src="/assets/js/blog.js"></script><script src="/assets/js/page.js"></script><script src="/assets/js/contact.js"></script></body></html>